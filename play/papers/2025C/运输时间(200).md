# (C卷,200分)- 运输时间（Java & JS & Python & C）

#### 题目描述

M（1 ≤ M ≤ 20）辆车需要在一条不能超车的单行道到达终点，起点到终点的距离为 N（1 ≤ N ≤ 400）。

速度快的车追上前车后，只能以前车的速度继续行驶，求最后一辆车到达目的地花费的时间。

注：每辆车固定间隔 1 小时出发，比如第一辆车 0 时出发，第二辆车 1 时出发，依次类推

#### 输入描述

第一行两个数字：M N，分别代表车辆数和到终点的距离，以空格分隔

接下来 M 行，每行一个数字 S，代表每辆车的速度。0 < S < 30

#### 输出描述

最后一辆车到达目的地花费的时间

#### 用例

输入| 2 11  
3  
2  
---|---  
输出| 5.5  
说明| 2辆车，距离11，0时出发的车速度快，1时出发的车，到达目的地花费5.5  
  
#### 题目解析

本题需要注意的是：速度快的车追上前车后，是可以和前车并行的。即本题的：

> 一条不能超车的单行道

指的应该是"单向"车道，即可能有多条单向车道，支持多辆车并行。

因此本题的解题就很简单了，由于后车不能超过前车，因此：

  * 如果后车正常行驶情况下，比前车更早到达，则会被前车阻碍，此时后车到达终点时刻，和前车一致
  * 如果后车正常行驶情况下，比前车更晚到达，则不会被前车阻碍，此时后车到达终点时刻，就是自己正常行驶到达终点的时刻


本题要求输出的是：到达目的地花费的时间 = 到达时刻 - 出发时刻

另外，需要注意，本题输出可能是小数，但是本题并没有说保留几位有效小数，我这边默认保留3位有效小数，四舍五入，实际考试时视情况改动。

#### JS算法源码
    
    
    const rl = require("readline").createInterface({ input: process.stdin });
    var iter = rl[Symbol.asyncIterator]();
    const readline = async () => (await iter.next()).value;
    
    void (async function () {
      const [m, n] = (await readline()).split(" ").map(Number);
    
      // 记录前车到达终点的时刻，本题后车不可能比前车更早到达，因此如果后车到达时刻 < 前车到达时刻arrived，则后车也是按照前车arrived时刻达到
      let arrived = 0;
    
      for (let i = 0; i < m; i++) {
        // 当前车的速度
        const speed = parseInt(await readline());
        // 当前车到达终点的时刻
        // * 当前车如果比前车更早到达，则被前车阻碍，按前车到达时间算
        // * 当前车如果比前车更晚到达，则不被前车阻碍，按后车到达时间算
        arrived = Math.max(arrived, n / speed + i); // n*1.0/speed是行驶花费时间； i是第i辆车的出发时间
      }
    
      // 到达时刻 - 出发时刻 = 路上花费的时间
      const cost = arrived - (m - 1);
    
      console.log(Number(cost.toFixed(3))); // 如果有小数位则至多保留3位
    })();
    

#### Java算法源码
    
    
    import java.text.NumberFormat;
    import java.util.Scanner;
    
    public class Main {
      public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
    
        int m = sc.nextInt();
        int n = sc.nextInt();
    
        // 记录前车到达终点的时刻，本题后车不可能比前车更早到达，因此如果后车到达时刻 < 前车到达时刻arrived，则后车也是按照前车arrived时刻达到
        double arrived = 0;
    
        for (int i = 0; i < m; i++) {
          // 当前车的速度
          double speed = sc.nextDouble();
          // 当前车到达终点的时刻
          // * 当前车如果比前车更早到达，则被前车阻碍，按前车到达时间算
          // * 当前车如果比前车更晚到达，则不被前车阻碍，按后车到达时间算
          arrived = Math.max(arrived, n / speed + i); // n*1.0/speed是行驶花费时间； i是第i辆车的出发时间
        }
    
        // 到达时刻 - 出发时刻 = 路上花费的时间
        double cost = arrived - (m - 1);
    
        // 格式化打印小数
        NumberFormat nf = NumberFormat.getInstance();
        nf.setMinimumFractionDigits(0); // 没有小数位则不保留
        nf.setMaximumFractionDigits(3); // 有小数位则至多保留3位
    
        System.out.println(nf.format(cost));
      }
    }
    

#### Python算法源码
    
    
    # 输入获取
    m, n = map(int, input().split())
    
    # 记录前车到达终点的时刻，本题后车不可能比前车更早到达，因此如果后车到达时刻 < 前车到达时刻arrived，则后车也是按照前车arrived时刻达到
    arrived = 0
    
    for i in range(m):
        # 当前车的速度
        speed = int(input())
        # 当前车到达终点的时刻
        # * 当前车如果比前车更早到达，则被前车阻碍，按前车到达时间算
        # * 当前车如果比前车更晚到达，则不被前车阻碍，按后车到达时间算
        arrived = max(arrived, n / speed + i)  # n*1.0/speed是行驶花费时间； i是第i辆车的出发时间
    
    # 到达时刻 - 出发时刻 = 路上花费的时间
    cost = arrived - (m - 1)
    
    print("{:g}".format(round(cost, 3)))  # 如果有小数位则至多保留3位，:g 用于去除无效小数位
    

#### C算法源码
    
    
    #include <stdio.h>
    #include <math.h>
    
    int main() {
        int m, n;
        scanf("%d %d", &m, &n);
    
        // 记录前车到达终点的时刻，本题后车不可能比前车更早到达，因此如果后车到达时刻 < 前车到达时刻arrived，则后车也是按照前车arrived时刻达到
        double arrived = 0;
    
        for(int i=0; i<m; i++) {
            // 当前车的速度
            double speed;
            scanf("%lf", &speed);
    
            // 当前车到达终点的时刻
            // * 当前车如果比前车更早到达，则被前车阻碍，按前车到达时间算
            // * 当前车如果比前车更晚到达，则不被前车阻碍，按后车到达时间算
            arrived = fmax(arrived, n / speed + i); // n*1.0/speed是行驶花费时间； i是第i辆车的出发时间
        }
    
        // 到达时刻 - 出发时刻 = 路上花费的时间
        double cost = arrived - (m - 1);
    
    
        // 至多保留3个小数位
        char res[100];
        sprintf(res, "%.3f", cost);
    
        // %g 格式 不会打印无效小数位
        printf("%g", atof(res));
    
        return 0;
    }
