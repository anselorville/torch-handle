# 快递单号
多多在快递公司负责快递单号录⼊⼯作，这些单号有严格的格式要求： 快递单号由3部分组成：2位⼤写字⺟（A~Z） + 6位数字 + 1位校验位校验位
计算规则： 取前8位（2 字⺟ + 6 数字）中每个字符的ASCII码之和，对26取余后，加上A的ASCII码，得到的字符即为校验位现在有⼀批可能存在校验位错误的单号，请你编写程序：
- 若单号格式正确且校验位正确，返回原单号
- 若前 8 位格式正确但校验位错误，返回修复后（校正校验位）的单号
- 若前 8 位格式错误（⾮ 2 字⺟ + 6 数字）或快递单号不满⾜格式要求，返回字符串Invalid
**输⼊描述**
共⼀⾏，⼀个字符串（1<=⻓度<=1024），表示待校验的快递单号
**输出描述**
共⼀⾏，⼀个字符串，表示修复后的快递单号，若⽆法修复则返回字符串Invalid


# 圣诞树
圣诞节快到了，有⼀棵挂满彩灯的⼆叉树，需要你来按照图纸装饰。彩灯有5种颜⾊变化，分别⽤1-5表示。1表示 红⾊， 2表示⻩⾊， 3表示蓝⾊， 4表示紫⾊， 5 表示绿⾊。每个节点都⼀个颜⾊控制器，每按⼀下都会产⽣⼀
个控制信号。控制信号将从当前节点出发向下传递，将当前节点的彩灯以及以当前节点为根节点的⼦树上的所有节点，切换到下⼀个颜⾊（ 红 -> ⻩-> 蓝 -> 紫 -> 绿 -> 红 ...） 循环切换。
给定⼆叉树的初始状态 initial 和 ⽬标状态 target,两者都以**层序遍历**产出的⼀维数组表示。数组元素对应对应位置节点的颜⾊，0表示该节点没有彩灯。
请给出从initial状态切换⾄target状态需要的最少控制器点击次数。
**注意：**
1. 控制器按⼀下所产⽣的控制信号，不只影响当前节点，也会影响以当前节点为根节点的⼦树上所有节点切换到下⼀个颜⾊（最终不⼀定是同⼀个颜⾊）。
2. 特别地，假设⼦树上的某个节点X上没有彩灯，则祖先节点处发出的控制信号将不会继续传递给X的后代节点。
**输⼊描述**
- 第⼀⾏输⼊为⼀个整数n, 代表inital 和 target 数组的⼤⼩。
- 第⼆⾏输⼊为n个整数，代表inital数组。
- 第三⾏输⼊为n个整数，代表target数组。
**其他：**
- 如果 initial[i] == 0, 则 target[i] 也⼀定为0。
- 1 <=initial.length <= 106
**输出描述**
⼀个整数，表示最少点击次数


# 魔法学院
多多进⼊了魔法学院学习，学院有 n ⻔不同的魔法课程，每⻔课程都有其独特的属性：
- power[i] ：学习这⻔课程能提升的魔法强度
- mana[i] ：学习这⻔课程需要消耗的法⼒值
- 学院的教学楼有 m 层，每层有不同的环境加成系数 bonus[j] （1 ≤ bonus[j] ≤ 3）。
- 多多总共有 M 点初始法⼒值。
**特殊规则：**
- 顺序学习：多多必须按顺序学习课程（必须先学课程1，再学课程2，以此类推）。
- 楼层绑定：每⻔课程只能在某⼀层完整学习，不能跨层。
- 强度加成：在第 j 层学习第 i ⻔课程时，获得的实际魔法强度为 power[i] × bonus[j]。
- 法⼒消耗：在第 j 层学习第 i ⻔课程时，消耗的实际法⼒值为 mana[i] × bonus[j]。
- 切换代价：多多可以在不同楼层之间切换课程，第⼀次学习选择楼层没有切换代价, 但每次切换可能会额外消耗楼层⾼度差的法⼒值。如果从低楼层切换到⾼楼层, ⽐如从1层切换到4层, 消耗3点法⼒, 如果从⾼楼层切换到低楼层, 则不会消耗额外的法⼒。
请求出在满⾜法⼒值限制（总法⼒消耗不超过 M ）的条件下，多多能获得的最⼤魔法强度总和(⽆需学完所有课程)。
**输⼊描述**
第⼀⾏三个整数 n , m , M （1 ≤ n ≤ 100, 1 ≤ m ≤ 5, 1 ≤ M ≤ 1000） 第⼆⾏ n 个整数，表示 power[i] （1 ≤ power[i] ≤ 100） 第三⾏ n 个整数，表示 mana[i] （1 ≤ mana[i] ≤ 100） 第四⾏ m 个整数，表示 bonus[j] （1 ≤ bonus[j] ≤ 3）
**输出描述**
输出⼀个整数，表示能获得的最⼤魔法强度总和。如果⽆法完成任何课程（例如，第⼀⻔课程在任何⼀层学习的法⼒消耗都超过 M ），则输出 0。
**补充说明**
- 对于 20% 的数据：n ≤ 10, 1 ≤ m ≤ 5, 1 ≤ M ≤ 1000
- 对于 60% 的数据：n ≤ 30, 1 ≤ m ≤ 5, 1 ≤ M ≤ 1000
- 对于 100% 的数据：1 ≤ n ≤ 100, 1 ≤ m ≤ 5, 1 ≤ M ≤ 1000


# ⼤⻥吃⼩⻥
多多在玩⼤⻥吃⼩⻥的游戏，⽬前有 n 条⻥，编号从 1 到 n 按顺序排列，第 i 条⻥的⾎量记为 ai 。
该游戏有以下规则：⼀条⻥只有在它的⾎量严格⼤于（不包含等于）它相邻的⻥时，它才能吃掉这条相邻的⻥，并且增加⾃身⾎量，增加值等于被吃掉的⻥的⾎量。如果没有任何⼀条⻥的⾎量严格⼤于它的邻居，则游戏结束。
例如，有 n=5，a=[2,2,3,1,4]。该过程可能如下进⾏：
- ⾸先，第 3 条⻥吃掉第 2 条⻥。第 3 条⻥的⾎量变为 5，第 2 条⻥被吃掉。
- 然后，第 3 条⻥吃掉第 1 条⻥（由于第 2 条⻥已被吃掉，他们现在是相邻的）。第 3 条⻥的⾎量变为7，第 1 条⻥被吃掉。
- 接着，第 5 条⻥吃掉第 4 条⻥。第 5 条⻥的⾎量变为 5，第 4 条⻥被吃掉。
- 最后，第 3 条⻥吃掉第 5 条⻥（由于第 4 条⻥已被吃掉，他们现在是相邻的）。第 3 条⻥的⾎量变为 12，第 5 条⻥被吃掉。
请你设计⼀个程序，⽤于求解：对于每⼀条⻥，计算在所有可能的进⻝顺序中，它被其他⻥吃掉所需的最少次数是多少？如果它不可能被吃掉，则输出−1。
**输⼊描述**
共2⾏，第⼀⾏包含⼀个正整数n，表示⻥的数量。(1<= n <=10^5)
第2⾏包含n个正整数: a1,a2,...,an(1<= n<=10^5)，表示每条⻥的⾎量。
测试样例中n条⻥的⾎量之和不会超过10^10。
**输出描述**
共1⾏，每⾏输出 n 个整数。第 i 个整数表示第 i 条⻥被其他⻥吃掉所需的最少次数；如果不可能被吃掉，则输出 −1。